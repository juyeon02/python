# Python 인덱싱과 슬라이싱 완전 가이드

# ============================================
# 리스트 생성과 기본 인덱싱
# ============================================

# list() 생성자를 사용한 리스트 생성
list1 = list()  # 빈 리스트 생성 ([]와 동일)
list2 = list("Hello")  # 문자열을 문자 단위로 분해하여 리스트로 변환

# 문자열 "Hello"가 리스트로 변환되는 과정:
# "Hello" → ['H', 'e', 'l', 'l', 'o']

# 인덱스 구조 이해:
# H  e  l  l  o  ← 각 문자
# 0  1  2  3  4  ← 양수 인덱스 (앞에서부터 시작, 0부터)
# -5 -4 -3 -2 -1 ← 음수 인덱스 (뒤에서부터 시작, -1부터)

print(list1)      # 출력: [] (빈 리스트)
print('list2', list2)  # 출력: list2 ['H', 'e', 'l', 'l', 'o']

# ============================================
# 양수 인덱스를 사용한 요소 접근
# ============================================

print('인덱스 0: ', list2[0])  # 출력: 인덱스 0: H (첫 번째 요소)
print('인덱스 3: ', list2[3])  # 출력: 인덱스 3: l (네 번째 요소)
print('인덱스 4: ', list2[4])  # 출력: 인덱스 4: o (다섯 번째, 마지막 요소)

# ============================================
# 음수 인덱스를 사용한 요소 접근
# ============================================

print('인덱스 -1: ', list2[-1])  # 출력: 인덱스 -1: o (마지막 요소)
print('인덱스 -3: ', list2[-3])  # 출력: 인덱스 -3: l (뒤에서 세 번째 요소)

# ============================================
# 리스트 요소 수정 (리스트는 가변 객체)
# ============================================

list2[4] = 'a'  # 인덱스 4의 요소 'o'를 'a'로 변경
print('list2', list2)  # 출력: list2 ['H', 'e', 'l', 'l', 'a']

# ============================================
# 문자열과 리스트의 차이점 (가변성)
# ============================================

# 문자열은 불변(immutable) 객체이므로 개별 문자를 수정할 수 없음
# text = 'python'
# text[1] = 'a'  # TypeError 발생! 문자열의 개별 문자는 수정 불가능
# print('text', text)

# ============================================
# 문자열 슬라이싱 기본 개념
# ============================================

text3 = "Hello"

# 슬라이싱을 위한 인덱스 구조 이해:
#  H  e  l  l  o  ← 각 문자
#  0  1  2  3  4  ← 양수 인덱스
# -5 -4 -3 -2 -1  ← 음수 인덱스

# ============================================
# 기본 슬라이싱 문법: [시작:끝:스텝]
# ============================================

print('text3[:]', text3[:])        # 출력: text3[:] Hello (전체 문자열 복사)
print('text3[:3]', text3[:3])      # 출력: text3[:3] Hel (처음부터 인덱스 2까지)
print('text3[2:4]', text3[2:4])    # 출력: text3[2:4] ll (인덱스 2부터 3까지)
print('text3[-3:-1]', text3[-3:-1])  # 출력: text3[-3:-1] ll (뒤에서 3번째부터 2번째까지)

# ============================================
# 스텝(step)을 활용한 고급 슬라이싱
# ============================================

print('text3[::-1]', text3[::-1])    # 출력: text3[::-1] olleH (전체를 역순으로)
print('text3[::-2]', text3[::-2])    # 출력: text3[::-2] olH (뒤에서부터 2칸씩 건너뛰며 역순)
# 출력: text3[:-4:-2] ol (끝에서 -4 전까지, 2칸씩 역순)
print('text3[:-4:-2]', text3[:-4:-2])

# 슬라이싱 스텝 해석 방법:
# [::-1] → 처음부터 끝까지, 역방향으로 1칸씩 이동
# [::-2] → 처음부터 끝까지, 역방향으로 2칸씩 이동
# [:-4:-2] → 끝에서 인덱스 -4 전까지, 역방향으로 2칸씩 이동

# ============================================
# 리스트 슬라이싱을 이용한 요소 교체
# ============================================

numbers = [10, 40, 30, 20, 40]
print('1. numbers', numbers)  # 출력: 1. numbers [10, 40, 30, 20, 40]

# 슬라이싱을 이용한 여러 요소 동시 교체
# numbers[1:3]은 인덱스 1, 2의 요소들 [40, 30]를 의미
numbers[1:3] = [40, 30, 20]  # 인덱스 1~2의 2개 요소를 3개 요소로 교체 (길이 변경 가능)
print('2. numbers', numbers)  # 출력: 2. numbers [10, 40, 30, 20, 20, 40]

# ============================================
# 다양한 슬라이싱 예제
# ============================================

# 현재 numbers = [10, 40, 30, 20, 20, 40] (위에서 수정된 상태)
#                  0   1   2   3   4   5  ← 인덱스

print('numbers[1:3]', numbers[1:3])    # 출력: numbers[1:3] [40, 30] (인덱스 1~2)
# 출력: numbers[:3:2] [10, 30] (처음~인덱스2까지, 2칸씩)
print('numbers[:3:2]', numbers[:3:2])

# 리스트 뒤집기 (역순으로 출력)
print('numbers 뒤집기', numbers[::-1])  # 출력: numbers 뒤집기 [40, 20, 20, 30, 40, 10]

print()  # 빈 줄 출력

# ============================
# del 키워드를 사용한 리스트 요소 삭제
# ============================

list1 = [10, 20, 30, 40, 50]
# 인덱스: 0   1   2   3   4

# del을 사용하여 특정 인덱스의 요소 삭제
del list1[3]  # 인덱스 3의 요소 40을 삭제
print(list1)  # 출력: [10, 20, 30, 50] (삭제 후 뒤 요소들이 앞으로 이동)

# del을 사용하여 슬라이싱 범위의 요소들 삭제
del list1[1:3]  # 인덱스 1,2의 요소들 [20, 30]을 삭제
print(list1)  # 출력: [10, 50]

# 주의사항: del list1을 실행하면 리스트 변수 자체가 메모리에서 삭제됨
# del list1  # 실행하면 이후에 list1에 접근할 때 NameError 발생
# print(list1)  # NameError: name 'list1' is not defined

print()  # 빈 줄 출력

# ============================
# 리스트 연산자 활용
# ============================

list1 = [1, 2, 3, 4, 5]
list2 = [2, 3, 4, 5]

# + 연산자: 두 리스트를 연결 (concatenation)
result = list1 + list2
print(result)  # 출력: [1, 2, 3, 4, 5, 2, 3, 4, 5] (두 리스트가 순서대로 연결)

# * 연산자: 리스트를 지정된 횟수만큼 반복 (repetition)
result = list1 * 3
print(result)  # 출력: [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5] (3번 반복)

# ============================
# 멤버십 연산자 (in, not in)
# ============================

# not in 연산자: 해당 값이 리스트에 없는지 확인
print(1 not in list1)  # 출력: False (1이 list1에 있으므로 "1이 없다"는 거짓)

# 추가 멤버십 연산자 예제:
print(1 in list1)      # 출력: True (1이 list1에 있음)
print(10 in list1)     # 출력: False (10이 list1에 없음)
print(10 not in list1)  # 출력: True (10이 list1에 없음)

# ============================================
# 슬라이싱 문법 총정리
# ============================================

"""
슬라이싱 기본 문법: [시작인덱스:끝인덱스:스텝]

1. 시작인덱스 (start):
   - 슬라이싱을 시작할 인덱스
   - 생략 시: 스텝이 양수면 처음(0)부터, 음수면 끝(-1)부터 시작

2. 끝인덱스 (stop):
   - 슬라이싱을 끝낼 인덱스 (해당 인덱스는 포함되지 않음!)
   - 생략 시: 스텝이 양수면 끝까지, 음수면 처음까지 진행

3. 스텝 (step):
   - 인덱스 증가/감소량 (기본값: 1)
   - 양수: 앞에서 뒤로 진행 (정방향)
   - 음수: 뒤에서 앞으로 진행 (역방향)

4. 요소 삭제:
   - del list[index]: 특정 인덱스의 요소 삭제
   - del list[start:end]: 범위 내 요소들 삭제
   - del list: 리스트 변수 자체를 삭제

5. 리스트 연산:
   - +: 연결 (concatenation) - 두 리스트를 하나로 합침
   - *: 반복 (repetition) - 리스트를 지정 횟수만큼 반복
   - in/not in: 멤버십 확인 - 특정 값의 존재 여부 확인
   
주요 슬라이싱 패턴:
- [:] → 전체 복사 (원본과 독립적인 새 객체)
- [::-1] → 전체 뒤집기 (역순)
- [::2] → 처음부터 2칸씩 건너뛰며 선택
- [1:4] → 인덱스 1부터 3까지 (4는 포함 안됨)
- [-3:] → 뒤에서 3번째부터 끝까지
- [:-2] → 처음부터 뒤에서 3번째까지 (뒤에서 2번째는 포함 안됨)

중요한 특징:
- 문자열: 불변객체(immutable)로 개별 문자 수정 불가
- 리스트: 가변객체(mutable)로 슬라이싱을 통한 여러 요소 동시 수정 가능
- 음수 인덱스: 뒤에서부터 세는 방식 (-1이 마지막 요소)
- 슬라이싱 결과: 항상 새로운 객체 생성 (원본은 변경되지 않음)
- 범위 초과: 인덱스가 범위를 벗어나도 에러가 발생하지 않음 (빈 결과 반환)
"""


# Python 리스트 메서드 완전 가이드

# ============================================
# 요소 추가 메서드
# ============================================

numbers = [10, 21, 15, 22, 54]

# append() 메서드: 리스트의 끝에 하나의 요소를 추가
numbers.append(20)
print(numbers)  # [10, 21, 15, 22, 54, 20]

numbers.append(12)
print(numbers)  # [10, 21, 15, 22, 54, 20, 12]

# extend() 메서드: 리스트의 끝에 반복 가능한 객체의 모든 요소를 추가
numbers.extend([19])  # 리스트 [19]의 요소인 19를 추가
print(numbers)  # [10, 21, 15, 22, 54, 20, 12, 19]

numbers.extend([5, 29])  # 리스트 [5, 29]의 모든 요소를 개별적으로 추가
print(numbers)  # [10, 21, 15, 22, 54, 20, 12, 19, 5, 29]

# ============================================
# append vs extend 차이점 비교
# ============================================

# append: 전달받은 객체를 하나의 요소로 추가 (객체 자체가 추가됨)
numbers.append([1, 2, 3])  # 리스트 [1, 2, 3] 전체가 하나의 요소로 추가
print(numbers)  # [10, 21, 15, 22, 54, 20, 12, 19, 5, 29, [1, 2, 3]]

# extend: 반복 가능한 객체의 각 요소들을 개별적으로 추가
list2 = [6, 7, 8]
numbers.extend(list2)  # list2의 각 요소 6, 7, 8이 개별적으로 추가됨
print(numbers)  # [10, 21, 15, 22, 54, 20, 12, 19, 5, 29, [1, 2, 3], 6, 7, 8]

# insert() 메서드: 지정된 인덱스에 요소를 삽입
# numbers.insert(2, 30)  # 인덱스 2 위치에 30을 삽입
# print(numbers)  # 인덱스 2에 30이 삽입되고, 기존 요소들은 뒤로 밀림

# ============================================
# 요소 삭제 메서드
# ============================================

fruits = ["사과", "바나나", "오렌지", "바나나", "포도"]

# remove() 메서드: 지정된 값의 첫 번째 발견 요소를 제거
fruits.remove('바나나')  # 첫 번째 '바나나'만 제거됨 (두 번째 '바나나'는 남아있음)
print(fruits)  # ['사과', '오렌지', '바나나', '포도']

# pop() 메서드: 지정된 인덱스의 요소를 제거하고 반환 (기본값은 마지막 요소)
removed = fruits.pop()  # 마지막 요소인 '포도'를 제거하고 반환
print(removed)  # 포도
print(fruits)  # ['사과', '오렌지', '바나나']

# pop(인덱스) 메서드: 특정 인덱스의 요소를 제거하고 반환
removed = fruits.pop(1)  # 인덱스 1의 요소인 '오렌지'를 제거하고 반환
print(removed)  # 오렌지
print(fruits)  # ['사과', '바나나']

# clear() 메서드: 리스트의 모든 요소를 제거 (리스트는 빈 상태가 됨)
fruits.clear()
print(fruits)  # []

# ============================================
# 요소 검색, 정렬 메서드
# ============================================

numbers = [1, 2, 6, 9, 5, 3, 2, 4, 7]

# index() 메서드: 지정된 값의 첫 번째 인덱스를 반환
idx = numbers.index(6)  # 값 6이 처음 나타나는 인덱스를 찾기
print('idx: ', idx)  # idx: 2 (인덱스 2에 6이 있음)

idx = numbers.index(9)  # 값 9가 처음 나타나는 인덱스를 찾기
print('idx: ', idx)  # idx: 3 (인덱스 3에 9가 있음)

# count() 메서드: 지정된 값이 리스트에 나타나는 횟수를 반환
count = numbers.count(2)  # 값 2가 리스트에 몇 번 나타나는지 세기
print('count: ', count)  # count: 2 (2가 두 번 나타남)

# sort() 메서드: 원본 리스트를 직접 정렬 (원본 리스트가 변경됨)
numbers.sort()  # 오름차순으로 정렬 (작은 수부터 큰 수 순서)
print('numbers: ', numbers)  # numbers: [1, 2, 2, 3, 4, 5, 6, 7, 9]

numbers.sort(reverse=True)  # 내림차순으로 정렬 (큰 수부터 작은 수 순서)
print('numbers: ', numbers)  # numbers: [9, 7, 6, 5, 4, 3, 2, 2, 1]

# ============================================
# sorted() 함수: 원본을 변경하지 않고 정렬된 새 리스트 반환
# ============================================

original = [3, 2, 5, 7, 1]

# sorted() 함수는 원본 리스트를 변경하지 않고 정렬된 새로운 리스트를 반환
sorted_list = sorted(original)  # 오름차순으로 정렬된 새 리스트 생성
sorted_r_list = sorted(original, reverse=True)  # 내림차순으로 정렬된 새 리스트 생성

print('original: ', original)  # original: [3, 2, 5, 7, 1] (원본 리스트는 변경되지 않음)
print('sorted_list: ', sorted_list)  # sorted_list: [1, 2, 3, 5, 7]
print('sorted_r_list: ', sorted_r_list)  # sorted_r_list: [7, 5, 3, 2, 1]

# ============================================
# 내장 함수들 (리스트와 함께 사용되는 유용한 함수들)
# ============================================

numbers = [5, 2, 7, 3, 11, 45]

# max() 함수: 리스트에서 가장 큰 값을 반환
max_num = max(numbers)
print('max_num', max_num)  # max_num 45

# min() 함수: 리스트에서 가장 작은 값을 반환
min_num = min(numbers)
print('min_num', min_num)  # min_num 2

# sum() 함수: 리스트의 모든 숫자 요소들의 합계를 반환
sum_num = sum(numbers)  # 5 + 2 + 7 + 3 + 11 + 45 = 73
print('sum_num', sum_num)  # sum_num 73

# ============================================
# 추가 설명
# ============================================

"""
리스트 메서드와 함수의 차이점:
1. 메서드 (append, extend, remove, pop, clear, sort 등):
   - 리스트 객체에 직접 적용됨 (list.method())
   - 대부분 원본 리스트를 직접 수정함
   - 반환값이 None인 경우가 많음

2. 함수 (sorted, max, min, sum 등):
   - 리스트를 매개변수로 받음 (function(list))
   - 원본 리스트를 변경하지 않음
   - 결과값을 반환함

주요 활용 팁:
- 원본 리스트를 보존하고 싶다면 sorted() 함수 사용
- 메모리 효율성을 위해 원본을 직접 수정해도 된다면 sort() 메서드 사용
- remove()는 첫 번째 일치하는 요소만 제거하므로 주의
- pop()은 제거와 동시에 값을 반환하므로 제거된 값이 필요할 때 유용
"""
