# Python 리스트 실습 문제 완전 해설

# ============================
# 첫번째 요소와 마지막 요소 접근
# ============================

nums = [10, 20, 30, 40, 50]
# 양수 인덱스:  0   1   2   3   4
# 음수 인덱스: -5  -4  -3  -2  -1

print('첫번째 요소:', nums[0])   # 출력: 첫번째 요소: 10 (양수 인덱스 0 사용)
print('마지막 요소:', nums[-1])  # 출력: 마지막 요소: 50 (음수 인덱스 -1 사용)
print()  # 빈 줄 출력

# ============================
# 가운데 세 개의 요소 추출
# ============================

nums = [100, 200, 300, 400, 500, 600, 700]
# 인덱스: 0    1    2    3    4    5    6
# 총 7개 요소 → 가운데 인덱스는 3 (7//2 = 3)

mid = len(nums) // 2  # mid = 7 // 2 = 3 (정수 나눗셈으로 가운데 인덱스 계산)
print('가운데 세 개의 요소:', nums[mid-1:mid+2])
# nums[3-1:3+2] → nums[2:5] → 인덱스 2,3,4의 요소들 → [300, 400, 500]
# 출력: 가운데 세 개의 요소: [300, 400, 500]
print()

# ============================
# 리스트의 모든 원소를 두 배로 만들기
# ============================

nums = [1, 2, 3, 4, 5]
# 반복문을 사용하여 각 요소에 접근하고 2를 곱함
for i in range(len(nums)):  # i는 0,1,2,3,4 순서로 변화 (리스트 길이만큼 반복)
    nums[i] *= 2    # nums[i] = nums[i] * 2와 동일한 복합 대입 연산자
    # 1회차: nums[0] = 1 * 2 = 2
    # 2회차: nums[1] = 2 * 2 = 4
    # 3회차: nums[2] = 3 * 2 = 6
    # 4회차: nums[3] = 4 * 2 = 8
    # 5회차: nums[4] = 5 * 2 = 10

print('nums:', nums)  # 출력: nums: [2, 4, 6, 8, 10]
print()

# ============================
# 리스트 뒤집기 (슬라이싱 활용)
# ============================

items = ['a', 'b', 'c', 'd', 'e']
# [::-1]은 전체 리스트를 역순으로 슬라이싱하는 패턴
# 시작:끝:스텝 → 전체:전체:-1 (뒤에서부터 앞으로 1칸씩)
print('리스트 뒤집기:', items[::-1])  # 출력: 리스트 뒤집기: ['e', 'd', 'c', 'b', 'a']
print()

# ============================
# 짝수 인덱스 요소만 출력 (0, 2, 4, ...)
# ============================

data = ['zero', 'one', 'two', 'three', 'four', 'five']
# 인덱스:  0      1     2      3       4       5
# [::2]는 처음부터 끝까지 2칸씩 건너뛰며 슬라이싱
# 인덱스 0('zero'), 2('two'), 4('four') 선택
print('짝수 인덱스 요소:', data[::2])  # 출력: 짝수 인덱스 요소: ['zero', 'two', 'four']
print()

# ============================
# 슬라이싱으로 리스트의 일부 요소를 다른 요소들로 교체
# ============================

movies = ['인셉션', '인터스텔라', '어벤져스', '라라랜드', '기생충']
# 인덱스:   0        1         2        3        4

# movies[2:4]는 인덱스 2,3의 요소들 ['어벤져스', '라라랜드']를 의미
# 슬라이싱 교체: 기존 2개 요소를 새로운 2개 요소로 교체 (길이 유지)
movies[2:4] = ['매트릭스', '타이타닉']
print('movies:', movies)  # 출력: movies: ['인셉션', '인터스텔라', '매트릭스', '타이타닉', '기생충']
print()

# ============================
# 특정 규칙에 따라 요소 추출 (시작:끝:스텝)
# ============================

subjects = ['국어', '수학', '영어', '물리', '화학',
            '생물', '역사', '지구과학', '윤리']
# 인덱스:  0      1      2      3      4
#         5      6      7         8

# subjects[3:9:2] → 인덱스 3부터 8까지(9 미포함) 2칸씩 건너뛰며 추출
# 선택되는 인덱스: 3('물리'), 5('생물'), 7('지구과학')
result = subjects[3:9:2]
print('특정 규칙 추출 결과:', result)  # 출력: 특정 규칙 추출 결과: ['물리', '생물', '지구과학']
print()

# ============================
# 리스트를 3구간으로 나누어 각각 역순으로 만든 후 출력
# ============================

data = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
# 인덱스: 0    1    2    3    4    5    6    7    8
# 총 9개 요소를 3개씩 나누어 각 구간을 역순으로 처리

# 첫 번째 구간: 인덱스 0~2 (3개 요소)
part1 = data[0:3][::-1]   # data[0:3] → ['A','B','C'] → 뒤집기 → ['C','B','A']
# 두 번째 구간: 인덱스 3~5 (3개 요소)
part2 = data[3:6][::-1]   # data[3:6] → ['D','E','F'] → 뒤집기 → ['F','E','D']
# 세 번째 구간: 인덱스 6~8 (3개 요소)
part3 = data[6:9][::-1]   # data[6:9] → ['G','H','I'] → 뒤집기 → ['I','H','G']

print('3구간 역순 결과:', part1, part2, part3, sep=' ')
# 출력: 3구간 역순 결과: ['C', 'B', 'A'] ['F', 'E', 'D'] ['I', 'H', 'G']
print()

# ============================
# 추가 실습: 다양한 슬라이싱 패턴
# ============================

numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 홀수 인덱스 요소만 추출 (1, 3, 5, 7, 9)
print('홀수 인덱스 요소:', numbers[1::2])  # 출력: 홀수 인덱스 요소: [1, 3, 5, 7, 9]

# 뒤에서 3개 요소만 추출
print('뒤에서 3개:', numbers[-3:])  # 출력: 뒤에서 3개: [7, 8, 9]

# 처음 5개 중에서 2칸씩 건너뛰며 추출
print('처음 5개 중 2칸씩:', numbers[:5:2])  # 출력: 처음 5개 중 2칸씩: [0, 2, 4]

# 중간 부분 역순으로 추출 (인덱스 2~7을 역순)
print('중간부분 역순:', numbers[2:8][::-1])  # 출력: 중간부분 역순: [7, 6, 5, 4, 3, 2]
print()

# ============================
# 종합 정리
# ============================

"""
주요 리스트 조작 기법 완전 정리:

1. 인덱싱 (단일 요소 접근):
   - 양수 인덱스: 앞에서부터 0, 1, 2, ... (첫 요소는 0)
   - 음수 인덱스: 뒤에서부터 -1, -2, -3, ... (마지막 요소는 -1)
   - 범위 초과 시 IndexError 발생

2. 슬라이싱 (여러 요소 접근):
   - 기본 문법: [시작:끝:스텝]
   - 끝 인덱스는 포함되지 않음 (미만의 개념)
   - 범위 초과 시 에러 없이 빈 리스트 또는 일부만 반환

3. 슬라이싱 주요 패턴:
   - [::-1]: 전체 뒤집기 (역순)
   - [::2]: 짝수 인덱스 (0, 2, 4, ...)
   - [1::2]: 홀수 인덱스 (1, 3, 5, ...)
   - [-n:]: 뒤에서 n개
   - [:n]: 앞에서 n개
   - [start:end]: 특정 범위

4. 요소 수정 방법:
   - 개별 수정: list[index] = new_value
   - 범위 수정: list[start:end] = new_list
   - 길이 변경 가능: 다른 길이의 리스트로 교체 가능

5. 실용적 응용:
   - 가운데 요소: list[len(list)//2]
   - 리스트 분할: 슬라이싱으로 구간별 처리
   - 조건부 추출: 스텝을 활용한 패턴 추출
   - 복합 연산: 슬라이싱 + 뒤집기 조합

6. 성능 고려사항:
   - 슬라이싱은 새로운 리스트 객체를 생성 (메모리 사용)
   - 큰 리스트에서는 메모리 효율성 고려 필요
   - 반복문보다 슬라이싱이 일반적으로 더 빠름

"""


# ============================
# del을 사용한 리스트 요소 삭제 예제
# ============================

# ============================
# 예제 1: 슬라이싱을 이용한 범위 삭제
# ============================

fruits = ['apple', 'bananan', 'cherry', 'grape', 'watermelon', 'strawberry']
# 인덱스:  0        1         2        3       4             5
# 주의: 'bananan'은 오타 ('banana'가 정확한 철자)

print('삭제 전:', fruits)
# 출력: 삭제 전: ['apple', 'bananan', 'cherry', 'grape', 'watermelon', 'strawberry']

# del fruits[1:4] → 인덱스 1, 2, 3의 요소들을 삭제
# 삭제될 요소들: fruits[1]='bananan', fruits[2]='cherry', fruits[3]='grape'
# 슬라이싱 규칙: 시작 인덱스 포함, 끝 인덱스 미포함 (1 이상 4 미만)
del fruits[1:4]

print('삭제 후:', fruits)
# 출력: 삭제 후: ['apple', 'watermelon', 'strawberry']
# 남은 요소들: fruits[0]='apple', fruits[4]='watermelon', fruits[5]='strawberry'

print()  # 빈 줄로 구분

# ============================
# 예제 2: 리스트 반복 후 특정 인덱스 삭제
# ============================

letters = ['A', 'B']
# 인덱스: 0    1

print('원본 리스트:', letters)
# 출력: 원본 리스트: ['A', 'B']

# * 연산자로 리스트를 3번 반복
result = letters * 3
# result = ['A', 'B'] + ['A', 'B'] + ['A', 'B'] = ['A', 'B', 'A', 'B', 'A', 'B']
# 새로운 인덱스: 0    1    2    3    4    5

print('3번 반복 후:', result)
# 출력: 3번 반복 후: ['A', 'B', 'A', 'B', 'A', 'B']

# del result[2] → 인덱스 2의 요소 'A' 삭제
del result[2]
# 삭제 전: ['A', 'B', 'A', 'B', 'A', 'B']
#           0    1    2    3    4    5
# 삭제 후: ['A', 'B',      'B', 'A', 'B']  → 뒤의 요소들이 앞으로 이동
#           0    1         2    3    4

print('인덱스 2 삭제 후:', result)
# 출력: 인덱스 2 삭제 후: ['A', 'B', 'B', 'A', 'B']

print()

# ============================
# 추가 예제: 다양한 삭제 패턴
# ============================

# 예제 3: 마지막 요소 삭제
numbers = [1, 2, 3, 4, 5]
print('삭제 전 numbers:', numbers)
del numbers[-1]  # 마지막 요소 삭제 (음수 인덱스 사용)
print('마지막 요소 삭제 후:', numbers)
# 출력: 마지막 요소 삭제 후: [1, 2, 3, 4]

print()

# 예제 4: 처음과 끝 요소 동시 삭제
colors = ['red', 'green', 'blue', 'yellow', 'purple']
print('삭제 전 colors:', colors)
del colors[0]    # 첫 번째 요소 삭제
del colors[-1]   # 마지막 요소 삭제 (인덱스가 재조정됨)
print('처음과 끝 삭제 후:', colors)
# 출력: 처음과 끝 삭제 후: ['green', 'blue', 'yellow']

print()

# 예제 5: 스텝을 활용한 삭제 (주의: 뒤에서부터 삭제해야 안전)
data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print('삭제 전 data:', data)

# 짝수 인덱스 요소들을 뒤에서부터 삭제 (인덱스 변경 방지)
# 인덱스 8, 6, 4, 2, 0 순서로 삭제
for i in [8, 6, 4, 2, 0]:  # 역순으로 삭제
    del data[i]

print('짝수 인덱스 삭제 후:', data)
# 출력: 짝수 인덱스 삭제 후: [1, 3, 5, 7, 9]

# ============================
# 중요한 주의사항과 팁
# ============================

"""
del을 사용한 리스트 요소 삭제 완전 가이드:

1. 기본 문법:
   - del list[index]: 특정 인덱스 삭제
   - del list[start:end]: 범위 삭제 (start 이상 end 미만)
   - del list[start:end:step]: 스텝 간격으로 삭제

2. 삭제 후 인덱스 변화:
   - 요소 삭제 후 뒤의 모든 요소들이 앞으로 이동
   - 리스트의 길이가 감소
   - 기존 인덱스 번호가 무효화될 수 있음

3. 안전한 삭제 방법:
   - 여러 요소 삭제 시 뒤에서부터 삭제 (큰 인덱스부터)
   - 또는 삭제할 요소들을 별도로 수집 후 일괄 삭제
   - 반복문에서 삭제 시 역순으로 진행

4. del의 다양한 활용:
   - del variable: 변수 자체를 메모리에서 삭제
   - del list[:]: 리스트의 모든 요소 삭제 (빈 리스트 만들기)
   - del list[::2]: 짝수 인덱스 요소들 삭제

5. 대안 방법들:
   - list.remove(value): 값으로 삭제 (첫 번째 발견 요소만)
   - list.pop(index): 삭제하면서 반환값 받기
   - list.clear(): 모든 요소 삭제

6. 성능 고려사항:
   - 앞쪽 요소 삭제는 느림 (모든 뒤 요소들이 이동)
   - 뒤쪽 요소 삭제는 빠름
   - 대량 삭제 시에는 새 리스트 생성이 더 효율적일 수 있음

주의: 존재하지 않는 인덱스 삭제 시 IndexError 발생
"""
